# Tax Authority (Portugal) Service (TAXPT) Specification v3.0

The Tax Authority (Portugal) Service allows integration with the Portuguese Tax Authority (AT) Web services.

The current version supports the following Tax Authority services:

- Dispatches
- Invoices
- SAF-T and CryptoSAF-T
- Series

## Dispatches

The following operations are available to communicate dispatches:

- `GetXmlAsync()`: Allows retrieving the XML that should be used to communicate a dispatch.
- `SendAsync()`: Allows communicating a dispatch by providing the XML retrieved with `GetXmlAsync()`.
- `RegisterAsync()`: Allows communicating a dispatch in a single step.

> The service allows communicating dispatches in a single step (`Register`) or in two steps (`GetXml` + `Send`). The later is provided to support scenarios where client applications may want to store the XML for diagnosis or may want to implement some kind of retry policies.

### Registering Dispatches

The XML for communicating a dispatch can first be retrieved and then passed in to the service for sending, like in the following example:

```csharp
DispatchData dispatch = (...);

ServiceOperationResult<string> getXmlResult = await this.Client
    .Dispatches
    .GetXmlAsync(dispatch)
    .ConfigureAwait(false);

string xml = getXmlResult.Body;

// (...)

ServiceOperationResult<DispatchRegistrationResult> registerResult = await this.Client
    .Dispatches
    .SendAsync(xml)
    .ConfigureAwait(false);

DispatchRegistrationResult result = registerResult.Body;
if (result.Succeeded)
{
    // (...)
}
```

## Invoices

The following operations are available to communicate invoices:

- `GetXmlAsync()`: Allows retrieving the XML that should be used to communicate an invoice.
- `SendAsync()`: Allows communicating an invoice by providing the XML retrieved with `GetXmlAsync()`.
- `RegisterAsync()`: Allows communicating an invoice in a single step.

### Registering Invoices

An invoice can be registered as follows:

```csharp
InvoiceData invoice = (...);

ServiceOperationResult<InvoiceRegistrationResult> registerResult = await this.Client
    .Invoices
    .RegisterAsync(invoice)
    .ConfigureAwait(false);

InvoiceRegistrationResult result = registerResult.Body;
if (result.Succeeded)
{
    // (...)
}
```

## SAF-T and CryptoSAF-T

The following operations are available to manipulate SAF-T files:

- `ValidateSaftAsync()` - allows validating a SAF-T file against the XSD schema provided by AT.

The following operations are available to manipulate CryptoSAF-T files:

- `EncryptSaftAsync()` - encrypts a SAF-T file and produces a CryptoSAF-T file.
- `DecryptCryptoSaftAsync()` - decrypts a CryptoSAF-T file to produce the original SAF-T file.

Producing CryptoSAF-T files requires an encryption key per fiscal year and VAT number that is provided by INCM. TAXPT also includes the following operations to obtain such encryption keys:

- `GetKeysAsync()` - allows retrieving a set of encryption keys for a number of pairs of fiscal year and VAT number.

### Validating a SAF-T File

A SAF-T file can be validated like in the following example:

```csharp

ValidateSaftRequest request = new ValidateSaftRequest()
{
    InputFileName = (...),
    Version = SaftVersion.Version104
};

ServiceOperationResult<ValidateSaftResponse> result = await this.Client
    .Saft
    .ValidateSaftAsync(request)
    .ConfigureAwait(false);

ValidateSaftResponse response = result.Body;
if (response.IsValid)
{
    (...)
}
```

### Generating a CryptoSAF-T File

A CryptoSAF-T file is generated by encrypting the original SAF-T file with the encryption key obtained previously (see bellow).

The result is a new file and a checksum of the original file. Both should be communicated to the Tax Authority.

```csharp
EncryptSaftRequest request = new EncryptSaftRequest()
{
    InputFileName = (...),
    OutputFileName = (...),
    Key = new EncryptionKeyData()
    {
        Key = (...),
        IV = (...)
    }
}

ServiceOperationResult<EncryptSaftResponse> result = await this.Client
    .CryptoSaft
    .EncryptSaftAsync(request)
    .ConfigureAwait(false);

EncryptSaftResponse response = result.Body;
(...)
```

### Decrypting a CryptoSAF-T File

The service provides, off course, the reverse operation:

```csharp
DecryptSaftRequest request = new DecryptSaftRequest()
{
    InputFileName = (...),
    OutputFileName = (...),
    Key = new EncryptionKeyData()
    {
        Key = (...),
        IV = (...)
    }
}

ServiceOperationResult<DecryptSaftResponse> result = await this.Client
    .CryptoSaft
    .DecryptCryptoSaftAsync(request)
    .ConfigureAwait(false);

DecryptSaftResponse response = result.Body;
(...)
```

### Obtaining Encryption Keys

Each encryption key is valid for a given fiscal year and VAT number. The service allows retrieving multiple keys in a single operation:

```csharp
EncryptionKeysRequest request = new EncryptionKeysRequest()
{
    Requests = new List<EncryptionKeyRequest>()
    {
        new EncryptionKeyRequest()
        {
            FiscalYear = (...),
            VatNumber = (...)
        },
        (...)
    },
    Endpoint = ServiceEndpoint.Production
}

ServiceOperationResult<IEnumerable<EncryptionKeyResponse>> result =
    await this.Client
        .EncryptionKeys
        .GetKeysAsync(request)
        .ConfigureAwait(false);

IEnumerable<EncryptionKeyResponse> responses = result.Body;

foreach (EncryptionKeyResponse response in responses)
{
    if (response.Result == EncryptionKeyResult.Available)
    {
        (...)
    }
}
```

> Notice that the service allows specifying the endpoint (on the INCM server) that should be used: either production or testing. This allows client applications to run tests for encryption keys without affecting the production encryption keys.

The response for each encryption key includes a **result** that provides information about the availability of the key. This is necessary because encryption keys are not immediately available when requested.

They first need to be generated by INCM and later retrieved from INCM using a "retrieval code" that is provided to the user (the "owner" of the VAT number) via the ViaCTT services.

> This is an authorization mechanism.

Thus the application will need to perform this operation on TAXPT several times until the key is finally available. In subsequent requests, since the key is stored in the TAXPT storage, it will be returned immediately.

When the result for a given key is `PendingRetrievalCode`, the application will need to ask the user for the retrieval code and provide it in the call to `GetKeys()`:

```csharp
EncryptionKeysRequest request = new EncryptionKeysRequest()
{
    Requests = new List<EncryptionKeyRequest>()
    {
        new EncryptionKeyRequest()
        {
            FiscalYear = (...),
            VatNumber = (...),
            RetrievalCode = (...)
        },
        (...)
    },
    Endpoint = ServiceEndpoint.Production
}
```

The possible values of `EncryptionKeyResponse.Result` are:

| Value | Description |
| - | - |
| `Pending` | The key has been requested to INCM but it is still being generated | 
| `PendingRetrievalCode` | The key has been generated by INCM but the client application needs to provide the retrieval code so it can be retrieved | 
| `PendingRetrieval` | The retrieval code was provided and the key is still being retrieved from INCM | 
| `Available` | The key is available (returned in `EncryptionKeyResponse.Key`) | 
| `Failure` | The key cannot be determined due to some error (see `EncryptionKeyResponse.Error`) | 

## Series

The following operations are available to communicate series:

- `RegisterAsync()`: Allows communicating a series in a single step.

> Since the communication of series has been postponed by AT, the current implementation on TAXPT is subject to change in the future.

### Registering Series

A series can be registered as follows:

```csharp
SeriesData series = (...);

ServiceOperationResult<SeriesRegistrationResult> registerResult = await this.Client
    .Series
    .RegisterAsync(series)
    .ConfigureAwait(false);

SeriesRegistrationResult result = registerResult.Body;
if (result.Succeeded)
{
    // (...)
}
```

## Certificates

The service uses the following certificates, retrieved from the Certificates Service:

- `TaxServicePTPublicKey`: The Tax Authority public key, used to encrypt data.
- `TaxServicePTPRIMAVERAPrivateKey`: PRIMAVERA's private key, used to protect the SSL communication with the Web services' production environment.
- `TaxServicePTTestPrivateKey`: The testing private key, used to protect the SSL communication with the Web services' testing environment.

> All these certificates are provided by AT.

## Brokered Services (AT)

The Web services provided by AT are normal SOAP (WCF) services that are brokered in the TAXPT service using a service proxy.

These Web services require:

- A special authentication process (for the sender and for the software publisher) that implies the use of HTTPS in the communication (hence the use of certificates).
- The payload to partially encrypted.
- Some headers to be included in the requests to identify the user performing them, the request date and a nonce (used to share the encryption keys).

That is why the Web services are invoked by a service proxy that uses a customized version of Basic HTTP Binding.

The invoices Web service is invoked using the `InvoicesServiceProxy` proxy:

```csharp
using (InvoicesServiceProxy proxy = await this.GetServiceProxyAsync(
    envelope.Header.Security.UsernameToken, 
    cancellationToken)
    .ConfigureAwait(false))
{
    // (...)

    RegisterInvoiceResponse response = await proxy
        .RegisterInvoiceAsync(request)
        .ConfigureAwait(false);

    // (...)
}
```

The dispatches Web services is invoked using the `DispatchesServiceProxy` proxy:

```csharp
using (DispatchesServiceProxy proxy = await this.GetServiceProxyAsync(
    envelope.Header.Security.UsernameToken, 
    cancellationToken)
    .ConfigureAwait(false))
{
    // (...)

    RegisterDispatchResponse response = await proxy
        .RegisterDispatchAsync(request)
        .ConfigureAwait(false);

    // (...)
}
```

The proxies are created like in the following example:

```csharp
private async Task<InvoicesServiceProxy> GetServiceProxyAsync(
    SoapHeaderSecurityUsernameToken userNameToken, 
    CancellationToken cancellationToken)
{
    ServiceProxyContext context = new ServiceProxyContext()
    {
        UserName = userNameToken.Username,
        Password = userNameToken.Password,
        Nonce = userNameToken.Nonce,
        Created = userNameToken.Created,
        Proxy = new ProxySettings()
        {
            Address = this.Client.Configuration.Proxy?.Address == null ? null : new Uri(this.Client.Configuration.Proxy.Address),
            UserName = this.Client.Configuration.Proxy?.UserName,
            Password = this.Client.Configuration.Proxy?.Password,
            UserDomain = this.Client.Configuration.Proxy?.UserDomain
        }
    };

    InvoicesServiceProxy result;

    if (this.Client.Configuration.Endpoints.UseTestingEndpoints)
    {
        X509Certificate2 httpCertificate = await this.CertificatesManager
            .GetCertificateAsync(
                CertificateKind.TestingEnvironment, 
                cancellationToken)
            .ConfigureAwait(false);

        X509Certificate2 publicKeyCertificate = await this.CertificatesManager
            .GetCertificateAsync(
                CertificateKind.TaxAuthorityPublicKey, 
                cancellationToken)
            .ConfigureAwait(false);

        context.Certificates = new CertificatesSettings()
        {
            HttpsCertificate = httpCertificate,
            TaxAuthorityPublicKey = publicKeyCertificate
        };

        result = new InvoicesServiceProxy(
            this.Client.ServiceProvider,
            new Uri(this.Client.Configuration.Endpoints.InvoicesTestingUri),
            context);
    }
    else
    {
        X509Certificate2 httpCertificate = await this.CertificatesManager
            .GetCertificateAsync(
                CertificateKind.PublisherPrivateKey,
                cancellationToken)
            .ConfigureAwait(false);

        X509Certificate2 publicKeyCertificate = await this.CertificatesManager
            .GetCertificateAsync(
                CertificateKind.TaxAuthorityPublicKey,
                cancellationToken)
            .ConfigureAwait(false);

        context.Certificates = new CertificatesSettings()
        {
            HttpsCertificate = httpCertificate,
            TaxAuthorityPublicKey = publicKeyCertificate
        };

        result = new InvoicesServiceProxy(
            this.Client.ServiceProvider,
            new Uri(this.Client.Configuration.Endpoints.InvoicesProductionUri),
            context);
    }

    return result;
}
```

## Brokered Services (INCM)

The Web services provided by INCM are normal SOAP (WCF) services that are brokered in the TAXPT service also using a service proxy.

These do not require authentication/authorization. They are, nevertheless, subject to throttling rules.

## More Information

<!-- markdown-link-check-disable -->
Additional technical details about the service are available [here](https://tfs.primaverabss.com/tfs/P.TEC.Elevation/Lithium/_versionControl?path=%24%2FLithium%2FMicroservices%2FCommon%2Ftaxpt%2Fmainline%2Fserver%2F.doc%2FTAXPT-Reference.md&_a=preview) (TFS).
<!-- markdown-link-check-enable -->